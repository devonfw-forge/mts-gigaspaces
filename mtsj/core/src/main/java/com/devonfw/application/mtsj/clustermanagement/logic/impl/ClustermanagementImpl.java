package com.devonfw.application.mtsj.clustermanagement.logic.impl;import static org.openspaces.extensions.QueryExtension.average;import static org.openspaces.extensions.QueryExtension.groupBy;import static org.openspaces.extensions.QueryExtension.max;import static org.openspaces.extensions.QueryExtension.sum;import java.io.IOException;import java.util.ArrayList;import java.util.Arrays;import java.util.Comparator;import java.util.List;import javax.annotation.security.RolesAllowed;import javax.inject.Inject;import javax.inject.Named;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import org.openspaces.core.GigaSpace;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.transaction.annotation.Transactional;import com.devonfw.application.mtsj.clustermanagement.common.api.to.ClusterCriteriaEto;import com.devonfw.application.mtsj.clustermanagement.common.api.to.ClusterDataEto;import com.devonfw.application.mtsj.clustermanagement.common.api.to.ClustersDataCto;import com.devonfw.application.mtsj.clustermanagement.common.api.to.ClustersDataEto;import com.devonfw.application.mtsj.clustermanagement.dataaccess.api.GeobookingEntity;import com.devonfw.application.mtsj.clustermanagement.logic.api.Clustermanagement;import com.devonfw.application.mtsj.general.common.impl.security.ApplicationAccessControlConfig;import com.devonfw.application.mtsj.general.logic.base.AbstractComponentFacade;import com.devonfw.application.mtsj.xap.ConcaveHull;import com.devonfw.application.mtsj.xap.Point;import com.gigaspaces.query.aggregators.GroupByAggregator;import com.gigaspaces.query.aggregators.GroupByResult;import com.gigaspaces.query.aggregators.GroupByValue;import com.j_spaces.core.client.SQLQuery;/** * @author dpatesan * *         Implementation of component interface of clustermanagement */@Named@Transactionalpublic class ClustermanagementImpl extends AbstractComponentFacade implements Clustermanagement {  private static final Logger LOG = LoggerFactory.getLogger(ClustermanagementImpl.class);  @Inject  private GigaSpace gigaSpace;  /**   * The constructor.   */  public ClustermanagementImpl() {    super();  }  @Override  @RolesAllowed(ApplicationAccessControlConfig.PERMISSION_FIND_GEO_CLUSTER)  public ClustersDataCto getGeoClusters(ClusterCriteriaEto criteria) {    String criteriastartDate = Long.toString(criteria.getStartBookingdate().toInstant().getEpochSecond());    String criteriaEndDate = Long.toString(criteria.getEndBookingdate().toInstant().getEpochSecond());    String criteriaDishId = criteria.getDishId();    // Start the Apache Zeppelin GeoBooking Notebook for creation of clusters    // Set the input parameters for the first paragraph of the GeoBooking Notebook    ProcessBuilder builder = new ProcessBuilder("cmd.exe", "/c",        "curl --header \"Content-Type: application/json\" --request POST --data \"{\"params\": {\"startDate\" : "            + criteriastartDate + ", \"endDate\" : " + criteriaEndDate + ", \"dishId\" : " + criteriaDishId + "}}\" \r"            + "http://localhost:9090/api/notebook/job/2FTCU8CG3/20201207-162610_349493717");    // Run all paragraphs of the GeoBooking Notebook    ProcessBuilder builder2 = new ProcessBuilder("cmd.exe", "/c",        "curl --request POST http://localhost:9090/api/notebook/job/2FTCU8CG3");    try {      Process p = builder.start();      p.waitFor();      Process p2 = builder2.start();      p2.waitFor();    } catch (IOException | InterruptedException e) {      // TODO Auto-generated catch block      e.printStackTrace();    }    LOG.debug("Clustering geo data.");    ClustersDataCto result = new ClustersDataCto();    ClustersDataEto data = new ClustersDataEto();    // Query the clusters from the Space, that were created by the Geobooking Notebook    SQLQuery<GeobookingEntity> query = new SQLQuery<>(GeobookingEntity.class,        "dishId = ? AND bookingDate >= ? AND bookingDate <= ? ");    query.setParameter(1, criteria.getDishId());    query.setParameter(2, criteria.getStartBookingdate().toInstant().getEpochSecond());    query.setParameter(3, criteria.getEndBookingdate().toInstant().getEpochSecond());    GroupByResult groupByResult = groupBy(this.gigaSpace, query,        new GroupByAggregator().select(max("prediction"), max("dishId"), max("dishName"), sum("amount"),            average("latitude"), average("longitude")).groupBy("prediction"));    List<ClusterDataEto> res = new ArrayList<>();    // Iterate over the clusters    for (GroupByValue group : groupByResult) {      // retrieve individual Information about a cluster      int id = group.getInt(0);      String dishId = group.getString(1);      String dishName = group.getString(2);      Long amount = group.getLong(3);      double y = group.getDouble(4);      double x = group.getDouble(5);      // Query the Coordinates of all the Entries that belong to a particular cluster      SQLQuery<GeobookingEntity> queryCoordinates = new SQLQuery<GeobookingEntity>(GeobookingEntity.class,          "dishId = ? AND bookingDate >= ? AND bookingDate <= ?  AND prediction = ? ").setProjections("latitude",              "longitude");      queryCoordinates.setParameter(1, criteria.getDishId());      queryCoordinates.setParameter(2, criteria.getStartBookingdate().toInstant().getEpochSecond());      queryCoordinates.setParameter(3, criteria.getEndBookingdate().toInstant().getEpochSecond());      queryCoordinates.setParameter(4, id);      List<GeobookingEntity> geobookings = Arrays.asList(this.gigaSpace.readMultiple(queryCoordinates));      // Create a List of Points (com.devonfw.application.mtsj.xap.Point), required for the concave Hull algorithm      ArrayList<Point> points = new ArrayList<>();      for (GeobookingEntity geobooking : geobookings) {        Point point = new Point(geobooking.getLongitude(), geobooking.getLatitude());        points.add(point);      }      ConcaveHull concaveHull = new ConcaveHull();      // Apply the concave Hull algorithm      ArrayList<Point> concaveHullPoints = concaveHull.calculateConcaveHull(points, 4);      ClusterDataEto clusterData = null;      try {        clusterData = new ClusterDataEto(String.valueOf(id), 0, dishId, dishName, amount, y, x,            toGeoJson(concaveHullPoints));      } catch (JSONException e) {        // TODO Auto-generated catch block        e.printStackTrace();      }      res.add(clusterData);    }    // Order By Amount because in GigaSpaces XAP it is not supported groupBy and orderBy at once    res.sort(Comparator.comparing(ClusterDataEto::getAmount));    data.setData(res);    result.setClustersData(data);    return result;  }  /**   * @param points List of points   * @return the string representation of GeoJson object of type Polygon   * @throws JSONException   */  public String toGeoJson(ArrayList<Point> points) throws JSONException {    JSONObject polygon = new JSONObject();    polygon.put("type", "Polygon");    JSONArray coordinatesArray = new JSONArray();    int i = 0;    for (Point point : points) {      JSONArray oneCoordinate = new JSONArray();      oneCoordinate.put(0, point.getX());      oneCoordinate.put(1, point.getY());      coordinatesArray.put(i, oneCoordinate);      i++;    }    polygon.append("coordinates", coordinatesArray);    return polygon.toString();  }}